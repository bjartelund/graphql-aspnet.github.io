"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4393],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),u=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=u(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),c=u(a),d=r,h=c["".concat(p,".").concat(d)]||c[d]||m[d]||i;return a?n.createElement(h,l(l({ref:t},s),{},{components:a})):n.createElement(h,l({ref:t},s))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},639:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const i={id:"malicious-queries",title:"Dealing with Malicious Queries",sidebar_label:"Malicious Queries",sidebar_position:1},l=void 0,o={unversionedId:"execution/malicious-queries",id:"execution/malicious-queries",title:"Dealing with Malicious Queries",description:"When GraphQL ASP.NET parses a query it creates two values that attempt to describe the query in terms of impact and server load; Max Depth and Estimated Complexity. There also exists limiters to these values that can be set in the schema configuration such that should any query plan exceed the limits you set, the plan will be rejected and the query not fulfilled.",source:"@site/docs/execution/malicious-queries.md",sourceDirName:"execution",slug:"/execution/malicious-queries",permalink:"/docs/execution/malicious-queries",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"malicious-queries",title:"Dealing with Malicious Queries",sidebar_label:"Malicious Queries",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Query Profiling",permalink:"/docs/execution/metrics"},next:{title:"Debugging",permalink:"/docs/development/debugging"}},p={},u=[{value:"Maximum Allowed Field Depth",id:"maximum-allowed-field-depth",level:2},{value:"Query Complexity",id:"query-complexity",level:2},{value:"Calculating Query Complexity",id:"calculating-query-complexity",level:2},{value:"Setting a Complexity Weight",id:"setting-a-complexity-weight",level:3},{value:"Implement Your Own Complexity Calculation",id:"implement-your-own-complexity-calculation",level:2}],s={toc:u};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When GraphQL ASP.NET parses a query it creates two values that attempt to describe the query in terms of impact and server load; Max Depth and Estimated Complexity. There also exists limiters to these values that can be set in the schema configuration such that should any query plan exceed the limits you set, the plan will be rejected and the query not fulfilled."),(0,r.kt)("h2",{id:"maximum-allowed-field-depth"},"Maximum Allowed Field Depth"),(0,r.kt)("p",null,"Field depth refers to how deeply nested a field is within a query."),(0,r.kt)("p",null,'In this example, for instance, the "search" field has a depth of 4 and the maximum depth reached is 6: ',(0,r.kt)("inlineCode",{parentName:"p"},"groceryStore > bakery > pastries > recipe > ingredients > name")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="Sample Query"',title:'"Sample','Query"':!0},'query SearchGroceryStore {\n    groceryStore {\n        bakery {\n            pastries {\n                search(nameLike: "chocolate"){\n                    name\n                    type\n                }\n                recipe(id: 15) {\n                    name\n                    ingredients {\n                        name\n                    }\n                }\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"This becomes important on large object graphs where its possible for a requestor to submit a query that is 10s or 100s of nodes deep. Running such a large query can have performance implications if ran en masse. Think of large, deeply nested queries run as part of a DDos attack."),(0,r.kt)("p",null,"To combat this you can set a maximum allowed depth for any query targeting your schema. During the parsing phase, once GraphQL has gathered enough information about the query document and target operation, it will inspect the maximum depth and if it violates your constraint, immediately reject the query without executing it."),(0,r.kt)("p",null,"To set a maximum allowed depth, set the appropriate property in your schema configuration at startup:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Configure Max Query Depth"',title:'"Configure',Max:!0,Query:!0,'Depth"':!0},"services.AddGraphQL(options =>\n{\n    options.ExecutionOptions.MaxQueryDepth = 15;\n});\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The default value for ",(0,r.kt)("inlineCode",{parentName:"p"},"MaxQueryDepth")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or no limit.")),(0,r.kt)("h2",{id:"query-complexity"},"Query Complexity"),(0,r.kt)("p",null,"The field depth is only part of the picture though. The way in which your fields interact with each other also plays a role."),(0,r.kt)("p",null,"Take for instance this query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="Sample Query"',title:'"Sample','Query"':!0},"query PhoneManufacturer {\n    allParts {\n        id\n        name\n        suppliers {\n            name\n            address\n        }\n    }\n}\n")),(0,r.kt)("p",null,"It would not be far fetched to assume that this phone manufacturer has at least 500 parts in their inventory and that those parts might be sourced from 2-3 individual suppliers. If that's the case our result is going to contain 3000 field resolutions (500 parts ","*"," 3 suppliers ","*"," 2 fields per supplier) just to show the name and address of each supplier. Thats a lot of data!!!! What if we added order history per supplier? Now we'd looking at 100,000+ results. The take away here is that your field resolutions can balloon quickly if you're not careful."),(0,r.kt)("p",null,"While this query only has a field depth of 3, ",(0,r.kt)("inlineCode",{parentName:"p"},"allParts > suppliers > name"),", the performance implications are much more impactful than the bakery in the first example because of the type of data involved. (Side note: this is a perfect example where a ",(0,r.kt)("a",{parentName:"p",href:"../controllers/batch-operations"},"batch operation")," would improve performance exponentially.)"),(0,r.kt)("p",null,"GraphQL will assign an ",(0,r.kt)("inlineCode",{parentName:"p"},"estimated complexity")," score to each query plan to help gauge the load its likely to incur on the server when trying to execute. As you might expect you can set a maximum allowed complexity value and reject any queries that exceed your limit:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Configure Max Allowed Query Complexity"',title:'"Configure',Max:!0,Allowed:!0,Query:!0,'Complexity"':!0},"services.AddGraphQL(options =>\n{\n    options.ExecutionOptions.MaxQueryComplexity = 50.00;\n});\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The default value for ",(0,r.kt)("inlineCode",{parentName:"p"},"MaxQueryComplexity")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or no limit.")),(0,r.kt)("p",null,"There is no magic bullet for choosing a maximum value as its going to be largely dependent on your data and how customers query it. "),(0,r.kt)("h2",{id:"calculating-query-complexity"},"Calculating Query Complexity"),(0,r.kt)("p",null,"After a query plan is generated, the chosen operation is inspected and weights are applied to each of the fields then summed together to generate a final score."),(0,r.kt)("p",null,"A complexity score is derived from these attributes:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Attribute"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Operation Type"),(0,r.kt)("td",{parentName:"tr",align:null},"This refers to the operation as a whole being a ",(0,r.kt)("inlineCode",{parentName:"td"},"mutation")," or a ",(0,r.kt)("inlineCode",{parentName:"td"},"query"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Execution Mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Whether or not a field is being executed as a batch operation or per source item.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Resolver Type"),(0,r.kt)("td",{parentName:"tr",align:null},"Is the field targeting a controller action, an object property or an object method?")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type Expression"),(0,r.kt)("td",{parentName:"tr",align:null},"Does the field produce 1 single item or a collection of items")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Complexity Factor"),(0,r.kt)("td",{parentName:"tr",align:null},"A user controlled value to influence the calculation for queries or mutations that are particularly long running")))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"estimated complexity")," of the query plan is the operation with the highest individual score."),(0,r.kt)("p",null,"The code for calculating the value can be seen in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql-aspnet/graphql-aspnet/blob/master/src/graphql-aspnet/Defaults/DefaultOperationComplexityCalculator%7BTSchema%7D.cs"},(0,r.kt)("inlineCode",{parentName:"a"},"DefaultOperationComplexityCalculator<TSchema>"))),(0,r.kt)("h3",{id:"setting-a-complexity-weight"},"Setting a Complexity Weight"),(0,r.kt)("p",null,"You can influence the complexity value of any given field by applying a weight to the field as part of its declaration."),(0,r.kt)("p",null,"The attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"[GraphField]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Query]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Mutation]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[QueryRoot]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[MutationRoot]")," expose access to this value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="BakeryController.cs"',title:'"BakeryController.cs"'},"public class BakeryController : GraphController\n{\n    // Complexity is a float value\n    [QueryRoot(Complexity = 1.3)]\n    public Donut RetrieveDonutType(int id){/*...*/}\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A factor greater than 1 will increase the weight applied to this field"),(0,r.kt)("li",{parentName:"ul"},"A factor less than 1 will decrease the weight"),(0,r.kt)("li",{parentName:"ul"},"The minimum value is ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," and the default value is ",(0,r.kt)("inlineCode",{parentName:"li"},"1"))),(0,r.kt)("h2",{id:"implement-your-own-complexity-calculation"},"Implement Your Own Complexity Calculation"),(0,r.kt)("p",null,"You can override how GraphQL calculates the complexity of any given query operation. Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"IQueryOperationComplexityCalculator<TSchema>")," and inject it into your DI container before calling ",(0,r.kt)("inlineCode",{parentName:"p"},".AddGraphQL()"),"."),(0,r.kt)("p",null,"This interface has one method where ",(0,r.kt)("inlineCode",{parentName:"p"},"IGraphFieldExecutableOperation")," represents the collection of requested fields contexts along with the input arguments, child fields and directives that are about to be executed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="IQueryOperationComplexityCalculator<TSchema>.cs"',title:'"IQueryOperationComplexityCalculator<TSchema>.cs"'},"public interface IQueryOperationComplexityCalculator<TSchema>\n{\n    float Calculate(IGraphFieldExecutableOperation operation);\n}\n")))}c.isMDXComponent=!0}}]);