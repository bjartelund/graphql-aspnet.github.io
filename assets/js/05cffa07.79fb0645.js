"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8447],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>y});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,y=d["".concat(s,".").concat(m)]||d[m]||c[m]||i;return n?r.createElement(y,o(o({ref:t},u),{},{components:n})):r.createElement(y,o({ref:t},u))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9413:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const i={id:"type-expressions",title:"Type Expressions",sidebar_label:"Type Expressions",sidebar_position:1},o=void 0,l={unversionedId:"advanced/type-expressions",id:"advanced/type-expressions",title:"Type Expressions",description:"The GraphQL specification states that when a field resolves a value that doesn't conform to the expected type expression of the field that the value is rejected, converted to null and an error added to the response.",source:"@site/docs/advanced/type-expressions.md",sourceDirName:"advanced",slug:"/advanced/type-expressions",permalink:"/docs/advanced/type-expressions",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"type-expressions",title:"Type Expressions",sidebar_label:"Type Expressions",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Subscriptions",permalink:"/docs/advanced/subscriptions"},next:{title:"Directives",permalink:"/docs/advanced/directives"}},s={},p=[{value:"Field Type Expressions",id:"field-type-expressions",level:2},{value:"Input Argument Type Expressions",id:"input-argument-type-expressions",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The GraphQL specification states that when a field resolves a value that doesn't conform to the expected type expression of the field that the value is rejected, converted to null and an error added to the response."),(0,a.kt)("p",null,"When the library build a schema it makes as few assumptions as possible about the data returned from your fields to result in as few errors as possible."),(0,a.kt)("p",null,"These assumptions are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Fields that return reference types ",(0,a.kt)("strong",{parentName:"li"},"can be")," null"),(0,a.kt)("li",{parentName:"ul"},"Fields that return value types ",(0,a.kt)("strong",{parentName:"li"},"cannot be")," null"),(0,a.kt)("li",{parentName:"ul"},"Fields that return Nullable value types (e.g. ",(0,a.kt)("inlineCode",{parentName:"li"},"int?"),") ",(0,a.kt)("strong",{parentName:"li"},"can be")," be null."),(0,a.kt)("li",{parentName:"ul"},"When a field returns an object that implements ",(0,a.kt)("inlineCode",{parentName:"li"},"IEnumerable<TType>"),' it will be presented to GraphQL as a "list of ',(0,a.kt)("inlineCode",{parentName:"li"},"TType"),'".')),(0,a.kt)("p",null,"Basically, if your method is able to return a value...then its valid as far as GraphQL is concerned."),(0,a.kt)("p",null,"Lets look at an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="BakeryController.cs"',title:'"BakeryController.cs"'},'[GraphRoute("bakery")]\npublic class BakeryController : GraphController\n{\n    [Query("donut")]\n    public Donut RetrieveDonut(int id)\n    {/*...*/}\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql",metastring:'title="Sample Query"',title:'"Sample','Query"':!0},"query {\n    donut(id: 15){\n        name\n        flavor\n    }\n}\n")),(0,a.kt)("p",null,"This action method could return a ",(0,a.kt)("inlineCode",{parentName:"p"},"Donut")," or return ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),". But should the donut field, from a GraphQL perspective, allow a null return value? The code certainly does and the rules above say fields that return a reference type can be null...but that's not what's important. Its ultimately your decision to decide if a \"null donut\" is allowed, not the C# compiler and not the assumptions made by the library."),(0,a.kt)("p",null,"On one hand, if a null value is returned, regardless of it being valid, the ",(0,a.kt)("em",{parentName:"p"},"outcome")," of the field is the same. When we return a null no child fields are processed. On the other hand, if null is not allowed we need to tell someone, let them know its nulled out not because it simply ",(0,a.kt)("em",{parentName:"p"},"is")," null but because a schema violation occurred."),(0,a.kt)("h2",{id:"field-type-expressions"},"Field Type Expressions"),(0,a.kt)("p",null,"You can add more specificity to your fields by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeExpression")," property of the various field declaration attributes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Example Custom Type Expressions"',title:'"Example',Custom:!0,Type:!0,'Expressions"':!0},'// Declare that a donut MUST be returned (null is invalid)\n// ----\n// Final Schema Syntax:  Donut!\n[Query("donut", TypeExpression = "Type!")]\npublic Donut RetrieveDonut(string id)\n{/*...*/}\n\n\n// Declare that a list must be returned but the elements of the list\n// could be null:\n// valid:    [donut1, null, donut2, donut3]\n// valid:    []\n// invalid:  null\n// ----\n// Final Schema Syntax:  [Donut]!\n[Query("donut", TypeExpression = "[Type]!")]\npublic IEnumerable<Donut> RetrieveDonut(string id)\n{/*...*/}\n\n\n// Declare that a list must be returned AND the elements of the list\n// must not be null:\n// valid:    [donut1, donut2, donut3]\n// valid:    []\n// invalid:  [donut1, null, donut2]\n// invalid:  null\n// ----\n// Final Schema Syntax:  [Donut!]!\n[Query("donut", TypeExpression = "[Type!]!")]\npublic IEnumerable<Donut> RetrieveDonut(string id)\n{/*...*/}\n')),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"Type")," is a place holder "),(0,a.kt)("p",{parentName:"admonition"},"The value ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," used in the examples is arbitrary and can be any valid string. The correct type name for the target schema will be used in its place at runtime.")),(0,a.kt)("p",null,"Note that the library will accept your type string even if it would be impossible, from a C# perspective, to return data that would match."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Data and Type Expression Mismatch"',title:'"Data',and:!0,Type:!0,Expression:!0,'Mismatch"':!0},'// QUERY EXECUTION ERROR\n// GraphQL will attempt to process a Donut as an IEnumerable and will fail\n[Query("donut", TypeExpression ="[Type]")]\npublic Donut RetrieveDonut(string id)\n{/*...*/}\n')),(0,a.kt)("admonition",{type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"When declared, the runtime will use your ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeExpression")," as law for any field declarations; skipping its internal checks. You can setup a scenario where by you could return data that the runtime could never validate as being correct and GraphQL will happily process it and return an error every time. ")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'"With great power comes great responsibility"  -Uncle Ben')),(0,a.kt)("h2",{id:"input-argument-type-expressions"},"Input Argument Type Expressions"),(0,a.kt)("p",null,"Similar to fields, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeExpression")," property on ",(0,a.kt)("inlineCode",{parentName:"p"},"[FromGraphQL]")," to add more specificity to your input arguments."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Type Expression on an Argument"',title:'"Type',Expression:!0,on:!0,an:!0,'Argument"':!0},'// Force the argument "id" to supply a string (it cannot be supplied as null)\n// -----------------\n// Final Type Expression of the \'id\' arg:  String!\n[Query]\npublic Donut RetrieveDonut([FromGraphQL(TypeExpression = "Type!")] string id)\n{/*...*/}\n')))}d.isMDXComponent=!0}}]);